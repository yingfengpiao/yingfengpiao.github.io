<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yingfengpiao.github.io</id>
    <title>迎风飘</title>
    <updated>2020-11-11T02:16:19.959Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://yingfengpiao.github.io"/>
    <link rel="self" href="https://yingfengpiao.github.io/atom.xml"/>
    <subtitle>迎风而立，顺风而飘</subtitle>
    <logo>https://yingfengpiao.github.io/images/avatar.png</logo>
    <icon>https://yingfengpiao.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 迎风飘</rights>
    <entry>
        <title type="html"><![CDATA[dijk]]></title>
        <id>https://yingfengpiao.github.io/post/dijk/</id>
        <link href="https://yingfengpiao.github.io/post/dijk/">
        </link>
        <updated>2020-11-11T01:28:52.000Z</updated>
        <content type="html"><![CDATA[<p>#dijkstra<br>
##迪杰斯特拉算法<br>
##单源最短路——复杂度(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)<br>
##<a href="https://www.luogu.com.cn/problem/P3371">洛谷弱化版</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt; 
using namespace std;
const int inf=2147483647;
int n,m,s;
struct node{
	int to;
	int next;
	int val;
}a[500001];
int head[10001];
int arr;
void add(int u,int v,int w){
	a[++arr].next=head[u];
	a[arr].to=v;
	a[arr].val=w;
	head[u]=arr;
}
long long dis[10001];
bool visit[10001];
void dijkstra(int x){
	for(int i=1;i&lt;=n;i++){
		if(i==x){
			dis[i]=0;
		}
		else{
			dis[i]=inf;
		}
	}
	int re=x;
	while(!visit[re]){
		visit[re]=1;
		int k=head[re];
		while(k!=0){
			dis[a[k].to]=min(a[k].val+dis[re],dis[a[k].to]);
			k=a[k].next;
		}
		long long minx=inf;
		for(int i=1;i&lt;=n;i++){
			if(!visit[i]&amp;&amp;dis[i]&lt;minx){
				minx=dis[i];
				re=i;
			}
		}
	}
}
int main()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i=1;i&lt;=m;i++){
		int u,v,w;
		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
		add(u,v,w);
	}
	dijkstra(s);
	for(int i=1;i&lt;=n;i++){
		cout&lt;&lt;dis[i]&lt;&lt;' ';
	}
	return 0;
}
</code></pre>
<p>ps: 最大值要按照题目的条件定义<s>我经常忘</s></p>
<p><a href="https://www.luogu.com.cn/problem/P4779">洛谷标准版</a></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">nlogn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span></p>
<p><s>习惯 手写堆</s></p>
<pre><code>
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
const int inf=2147483647;
int n,m,s;
struct node{
	int to;
	int next;
	int val;
}e[2000001];
int arr;
int head[1000001];
void add(int u,int v,int w){
	e[++arr].next=head[u];
	e[arr].to=v;
	e[arr].val=w;
	head[u]=arr;
}

struct num{
	int id;
	int val;
}queue[1000001];
int tail=1;
void shift_up(int x){
	while(x/2&gt;=1){
		if(queue[x].val&lt;queue[x/2].val){
			swap(queue[x],queue[x/2]);
			x/=2;
		}else{
			break;
		} 
	}
	return ;
}
void shift_down(int x,int n){
	while(x*2&lt;=n){
		int t=x*2;
		if(t+1&lt;=n&amp;&amp;queue[t+1].val&lt;queue[t].val){
			t++;
		}
		if(queue[x].val&gt;queue[t].val){
			swap(queue[x],queue[t]);
			x=t;
		}else{
			break;
		}
	}
	return ;
}
void push(num x){
	queue[tail++]=x;
	shift_up(tail-1);
	return ;
}
void pop(){
	swap(queue[1],queue[tail-1]);
	tail--;
	shift_down(1,tail-1);
}

int dis[1000001];
bool visit[100001];
void dijkstra(int x){
	for(int i=1;i&lt;=n;++i){
		if(i==x){
			dis[i]=0;
			push((num){i,0});
		}else{
			dis[i]=inf;
		}
	}
	while(tail!=1){
		int re=queue[1].id;
		pop();
		if(visit[re]) continue;
		visit[re]=1;
		int k=head[re];
		while(k!=0){
			if(dis[e[k].to]&gt;dis[re]+e[k].val){
				dis[e[k].to]=dis[re]+e[k].val;
				push((num){e[k].to,dis[e[k].to]});
			}
			k=e[k].next;
		}
	}
}
int main()
{
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
	for(int i=1;i&lt;=m;++i){
		int u,v,w;
		scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
		add(u,v,w);
	}
	dijkstra(s);
	for(int i=1;i&lt;=n;++i){
		printf(&quot;%d &quot;,dis[i]);
	}
	return 0;
}
</code></pre>
<p>nlogn<br>
std:优先队列</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#define N 100010
const int inf=2147483647;
using namespace std;
int n,m,s;
struct node{
  int next;
  int to;
  int val;
}e[2*N];
int arr;
int head[N];
void add(int u,int v,int w){
  e[++arr].next=head[u];
  e[arr].to=v;
  e[arr].val=w;
  head[u]=arr;
}
struct num{
  int x;
  int dis;
  bool operator &lt; (const num &amp;x) const {
    return dis&gt;x.dis;
  }
};
priority_queue&lt;num &gt; q;
int dis[N];
bool vis[N];
void dijkstra(int x){
  for(int i=1;i&lt;=n;++i){
    if(i==x){
      dis[i]=0;
    }else{
      dis[i]=inf;
    }
  }
  q.push((num){x,0});
  while(!q.empty()){
    num re=q.top();
    q.pop();
    if(vis[re.x]) continue;
    vis[re.x]=1;
    int k=head[re.x];
    while(k){
      if(dis[e[k].to]&gt;re.dis+e[k].val){
        dis[e[k].to]=re.dis+e[k].val;
        q.push((num){e[k].to,dis[e[k].to]});
      }
      k=e[k].next;
    }
  }
}
int main()
{
  scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s);
  for(int i=1;i&lt;=m;++i){
    int u,v,w;
    scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
    add(u,v,w);
  }
  dijkstra(s);
  for(int i=1;i&lt;=n;++i){
    cout&lt;&lt;dis[i]&lt;&lt;' ';
  }
  cout&lt;&lt;endl;
  return 0;
}

</code></pre>
<h3 id="为什么最大值inf赋值成2147483647不会炸">为什么最大值inf赋值成2147483647不会炸？？</h3>
<p>会炸的情况可能发生在 dis[re]+e[k].val</p>
<p>dis[re]肯定是被更新过的值</p>
<p>e[k].val也不会超范围</p>
<p>自然就没有什么问题</p>
]]></content>
    </entry>
</feed>